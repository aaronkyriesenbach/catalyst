// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.k14s.io/v1alpha1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps = {}): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps = {}) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Certificate#spec
   */
  readonly spec?: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * @schema CertificateSpec#alternativeNames
   */
  readonly alternativeNames?: string[];

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema CertificateSpec#caRef
   */
  readonly caRef?: CertificateSpecCaRef;

  /**
   * @schema CertificateSpec#commonName
   */
  readonly commonName?: string;

  /**
   * @schema CertificateSpec#duration
   */
  readonly duration?: number;

  /**
   * @schema CertificateSpec#extendedKeyUsage
   */
  readonly extendedKeyUsage?: string[];

  /**
   * @schema CertificateSpec#isCA
   */
  readonly isCa?: boolean;

  /**
   * @schema CertificateSpec#organization
   */
  readonly organization?: string;

  /**
   * @schema CertificateSpec#secretTemplate
   */
  readonly secretTemplate?: CertificateSpecSecretTemplate;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeNames': obj.alternativeNames?.map(y => y),
    'caRef': toJson_CertificateSpecCaRef(obj.caRef),
    'commonName': obj.commonName,
    'duration': obj.duration,
    'extendedKeyUsage': obj.extendedKeyUsage?.map(y => y),
    'isCA': obj.isCa,
    'organization': obj.organization,
    'secretTemplate': toJson_CertificateSpecSecretTemplate(obj.secretTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema CertificateSpecCaRef
 */
export interface CertificateSpecCaRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema CertificateSpecCaRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'CertificateSpecCaRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecCaRef(obj: CertificateSpecCaRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecSecretTemplate
 */
export interface CertificateSpecSecretTemplate {
  /**
   * @schema CertificateSpecSecretTemplate#metadata
   */
  readonly metadata?: CertificateSpecSecretTemplateMetadata;

  /**
   * @schema CertificateSpecSecretTemplate#stringData
   */
  readonly stringData?: { [key: string]: string };

  /**
   * @schema CertificateSpecSecretTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecSecretTemplate(obj: CertificateSpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_CertificateSpecSecretTemplateMetadata(obj.metadata),
    'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecSecretTemplateMetadata
 */
export interface CertificateSpecSecretTemplateMetadata {
  /**
   * @schema CertificateSpecSecretTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema CertificateSpecSecretTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CertificateSpecSecretTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecSecretTemplateMetadata(obj: CertificateSpecSecretTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema Password
 */
export class Password extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Password"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.k14s.io/v1alpha1',
    kind: 'Password',
  }

  /**
   * Renders a Kubernetes manifest for "Password".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PasswordProps = {}): any {
    return {
      ...Password.GVK,
      ...toJson_PasswordProps(props),
    };
  }

  /**
   * Defines a "Password" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PasswordProps = {}) {
    super(scope, id, {
      ...Password.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Password.GVK,
      ...toJson_PasswordProps(resolved),
    };
  }
}

/**
 * @schema Password
 */
export interface PasswordProps {
  /**
   * @schema Password#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Password#spec
   */
  readonly spec?: PasswordSpec;

}

/**
 * Converts an object of type 'PasswordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordProps(obj: PasswordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PasswordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PasswordSpec
 */
export interface PasswordSpec {
  /**
   * @schema PasswordSpec#digits
   */
  readonly digits?: number;

  /**
   * @schema PasswordSpec#length
   */
  readonly length?: number;

  /**
   * @schema PasswordSpec#lowercaseLetters
   */
  readonly lowercaseLetters?: number;

  /**
   * @schema PasswordSpec#secretTemplate
   */
  readonly secretTemplate?: PasswordSpecSecretTemplate;

  /**
   * @schema PasswordSpec#symbolCharSet
   */
  readonly symbolCharSet?: string;

  /**
   * @schema PasswordSpec#symbols
   */
  readonly symbols?: number;

  /**
   * @schema PasswordSpec#uppercaseLetters
   */
  readonly uppercaseLetters?: number;

}

/**
 * Converts an object of type 'PasswordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordSpec(obj: PasswordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digits': obj.digits,
    'length': obj.length,
    'lowercaseLetters': obj.lowercaseLetters,
    'secretTemplate': toJson_PasswordSpecSecretTemplate(obj.secretTemplate),
    'symbolCharSet': obj.symbolCharSet,
    'symbols': obj.symbols,
    'uppercaseLetters': obj.uppercaseLetters,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PasswordSpecSecretTemplate
 */
export interface PasswordSpecSecretTemplate {
  /**
   * @schema PasswordSpecSecretTemplate#metadata
   */
  readonly metadata?: PasswordSpecSecretTemplateMetadata;

  /**
   * @schema PasswordSpecSecretTemplate#stringData
   */
  readonly stringData?: { [key: string]: string };

  /**
   * @schema PasswordSpecSecretTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PasswordSpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordSpecSecretTemplate(obj: PasswordSpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_PasswordSpecSecretTemplateMetadata(obj.metadata),
    'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PasswordSpecSecretTemplateMetadata
 */
export interface PasswordSpecSecretTemplateMetadata {
  /**
   * @schema PasswordSpecSecretTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema PasswordSpecSecretTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'PasswordSpecSecretTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordSpecSecretTemplateMetadata(obj: PasswordSpecSecretTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema RSAKey
 */
export class RsaKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RSAKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.k14s.io/v1alpha1',
    kind: 'RSAKey',
  }

  /**
   * Renders a Kubernetes manifest for "RSAKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RsaKeyProps = {}): any {
    return {
      ...RsaKey.GVK,
      ...toJson_RsaKeyProps(props),
    };
  }

  /**
   * Defines a "RSAKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RsaKeyProps = {}) {
    super(scope, id, {
      ...RsaKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RsaKey.GVK,
      ...toJson_RsaKeyProps(resolved),
    };
  }
}

/**
 * @schema RSAKey
 */
export interface RsaKeyProps {
  /**
   * @schema RSAKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema RSAKey#spec
   */
  readonly spec?: RsaKeySpec;

}

/**
 * Converts an object of type 'RsaKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RsaKeyProps(obj: RsaKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RsaKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RsaKeySpec
 */
export interface RsaKeySpec {
  /**
   * @schema RsaKeySpec#secretTemplate
   */
  readonly secretTemplate?: RsaKeySpecSecretTemplate;

}

/**
 * Converts an object of type 'RsaKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RsaKeySpec(obj: RsaKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretTemplate': toJson_RsaKeySpecSecretTemplate(obj.secretTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RsaKeySpecSecretTemplate
 */
export interface RsaKeySpecSecretTemplate {
  /**
   * @schema RsaKeySpecSecretTemplate#metadata
   */
  readonly metadata?: RsaKeySpecSecretTemplateMetadata;

  /**
   * @schema RsaKeySpecSecretTemplate#stringData
   */
  readonly stringData?: { [key: string]: string };

  /**
   * @schema RsaKeySpecSecretTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RsaKeySpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RsaKeySpecSecretTemplate(obj: RsaKeySpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_RsaKeySpecSecretTemplateMetadata(obj.metadata),
    'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RsaKeySpecSecretTemplateMetadata
 */
export interface RsaKeySpecSecretTemplateMetadata {
  /**
   * @schema RsaKeySpecSecretTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema RsaKeySpecSecretTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RsaKeySpecSecretTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RsaKeySpecSecretTemplateMetadata(obj: RsaKeySpecSecretTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema SSHKey
 */
export class SshKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SSHKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.k14s.io/v1alpha1',
    kind: 'SSHKey',
  }

  /**
   * Renders a Kubernetes manifest for "SSHKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SshKeyProps = {}): any {
    return {
      ...SshKey.GVK,
      ...toJson_SshKeyProps(props),
    };
  }

  /**
   * Defines a "SSHKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SshKeyProps = {}) {
    super(scope, id, {
      ...SshKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SshKey.GVK,
      ...toJson_SshKeyProps(resolved),
    };
  }
}

/**
 * @schema SSHKey
 */
export interface SshKeyProps {
  /**
   * @schema SSHKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema SSHKey#spec
   */
  readonly spec?: SshKeySpec;

}

/**
 * Converts an object of type 'SshKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeyProps(obj: SshKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SshKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SshKeySpec
 */
export interface SshKeySpec {
  /**
   * @schema SshKeySpec#secretTemplate
   */
  readonly secretTemplate?: SshKeySpecSecretTemplate;

}

/**
 * Converts an object of type 'SshKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpec(obj: SshKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretTemplate': toJson_SshKeySpecSecretTemplate(obj.secretTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SshKeySpecSecretTemplate
 */
export interface SshKeySpecSecretTemplate {
  /**
   * @schema SshKeySpecSecretTemplate#metadata
   */
  readonly metadata?: SshKeySpecSecretTemplateMetadata;

  /**
   * @schema SshKeySpecSecretTemplate#stringData
   */
  readonly stringData?: { [key: string]: string };

  /**
   * @schema SshKeySpecSecretTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SshKeySpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecSecretTemplate(obj: SshKeySpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_SshKeySpecSecretTemplateMetadata(obj.metadata),
    'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SshKeySpecSecretTemplateMetadata
 */
export interface SshKeySpecSecretTemplateMetadata {
  /**
   * @schema SshKeySpecSecretTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema SshKeySpecSecretTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SshKeySpecSecretTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecSecretTemplateMetadata(obj: SshKeySpecSecretTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

