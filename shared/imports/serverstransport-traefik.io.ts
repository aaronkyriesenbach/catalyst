// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ServersTransport is the CRD implementation of a ServersTransport.
If no serversTransport is specified, the default@internal will be used.
The default@internal serversTransport is created from the static configuration.
More info: https://doc.traefik.io/traefik/v3.4/routing/services/#serverstransport_1
 *
 * @schema ServersTransport
 */
export class ServersTransport extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServersTransport"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.io/v1alpha1',
    kind: 'ServersTransport',
  }

  /**
   * Renders a Kubernetes manifest for "ServersTransport".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServersTransportProps): any {
    return {
      ...ServersTransport.GVK,
      ...toJson_ServersTransportProps(props),
    };
  }

  /**
   * Defines a "ServersTransport" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServersTransportProps) {
    super(scope, id, {
      ...ServersTransport.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServersTransport.GVK,
      ...toJson_ServersTransportProps(resolved),
    };
  }
}

/**
 * ServersTransport is the CRD implementation of a ServersTransport.
 * If no serversTransport is specified, the default@internal will be used.
 * The default@internal serversTransport is created from the static configuration.
 * More info: https://doc.traefik.io/traefik/v3.4/routing/services/#serverstransport_1
 *
 * @schema ServersTransport
 */
export interface ServersTransportProps {
  /**
   * @schema ServersTransport#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * ServersTransportSpec defines the desired state of a ServersTransport.
   *
   * @schema ServersTransport#spec
   */
  readonly spec: ServersTransportSpec;

}

/**
 * Converts an object of type 'ServersTransportProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServersTransportProps(obj: ServersTransportProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServersTransportSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ServersTransportSpec defines the desired state of a ServersTransport.
 *
 * @schema ServersTransportSpec
 */
export interface ServersTransportSpec {
  /**
   * CertificatesSecrets defines a list of secret storing client certificates for mTLS.
   *
   * @schema ServersTransportSpec#certificatesSecrets
   */
  readonly certificatesSecrets?: string[];

  /**
   * DisableHTTP2 disables HTTP/2 for connections with backend servers.
   *
   * @schema ServersTransportSpec#disableHTTP2
   */
  readonly disableHttp2?: boolean;

  /**
   * ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
   *
   * @schema ServersTransportSpec#forwardingTimeouts
   */
  readonly forwardingTimeouts?: ServersTransportSpecForwardingTimeouts;

  /**
   * InsecureSkipVerify disables SSL certificate verification.
   *
   * @schema ServersTransportSpec#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
   *
   * @schema ServersTransportSpec#maxIdleConnsPerHost
   */
  readonly maxIdleConnsPerHost?: number;

  /**
   * PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
   *
   * @schema ServersTransportSpec#peerCertURI
   */
  readonly peerCertUri?: string;

  /**
   * RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
   *
   * @schema ServersTransportSpec#rootCAs
   */
  readonly rootCAs?: ServersTransportSpecRootCAs[];

  /**
   * RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
   * Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
   *
   * @schema ServersTransportSpec#rootCAsSecrets
   */
  readonly rootCAsSecrets?: string[];

  /**
   * ServerName defines the server name used to contact the server.
   *
   * @schema ServersTransportSpec#serverName
   */
  readonly serverName?: string;

  /**
   * Spiffe defines the SPIFFE configuration.
   *
   * @schema ServersTransportSpec#spiffe
   */
  readonly spiffe?: ServersTransportSpecSpiffe;

}

/**
 * Converts an object of type 'ServersTransportSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServersTransportSpec(obj: ServersTransportSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificatesSecrets': obj.certificatesSecrets?.map(y => y),
    'disableHTTP2': obj.disableHttp2,
    'forwardingTimeouts': toJson_ServersTransportSpecForwardingTimeouts(obj.forwardingTimeouts),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'maxIdleConnsPerHost': obj.maxIdleConnsPerHost,
    'peerCertURI': obj.peerCertUri,
    'rootCAs': obj.rootCAs?.map(y => toJson_ServersTransportSpecRootCAs(y)),
    'rootCAsSecrets': obj.rootCAsSecrets?.map(y => y),
    'serverName': obj.serverName,
    'spiffe': toJson_ServersTransportSpecSpiffe(obj.spiffe),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
 *
 * @schema ServersTransportSpecForwardingTimeouts
 */
export interface ServersTransportSpecForwardingTimeouts {
  /**
   * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
   *
   * @schema ServersTransportSpecForwardingTimeouts#dialTimeout
   */
  readonly dialTimeout?: ServersTransportSpecForwardingTimeoutsDialTimeout;

  /**
   * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
   *
   * @schema ServersTransportSpecForwardingTimeouts#idleConnTimeout
   */
  readonly idleConnTimeout?: ServersTransportSpecForwardingTimeoutsIdleConnTimeout;

  /**
   * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
   *
   * @schema ServersTransportSpecForwardingTimeouts#pingTimeout
   */
  readonly pingTimeout?: ServersTransportSpecForwardingTimeoutsPingTimeout;

  /**
   * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
   *
   * @schema ServersTransportSpecForwardingTimeouts#readIdleTimeout
   */
  readonly readIdleTimeout?: ServersTransportSpecForwardingTimeoutsReadIdleTimeout;

  /**
   * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
   *
   * @schema ServersTransportSpecForwardingTimeouts#responseHeaderTimeout
   */
  readonly responseHeaderTimeout?: ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout;

}

/**
 * Converts an object of type 'ServersTransportSpecForwardingTimeouts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServersTransportSpecForwardingTimeouts(obj: ServersTransportSpecForwardingTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dialTimeout': obj.dialTimeout?.value,
    'idleConnTimeout': obj.idleConnTimeout?.value,
    'pingTimeout': obj.pingTimeout?.value,
    'readIdleTimeout': obj.readIdleTimeout?.value,
    'responseHeaderTimeout': obj.responseHeaderTimeout?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RootCA defines a reference to a Secret or a ConfigMap that holds a CA certificate.
 * If both a Secret and a ConfigMap reference are defined, the Secret reference takes precedence.
 *
 * @schema ServersTransportSpecRootCAs
 */
export interface ServersTransportSpecRootCAs {
  /**
   * ConfigMap defines the name of a ConfigMap that holds a CA certificate.
   * The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
   *
   * @schema ServersTransportSpecRootCAs#configMap
   */
  readonly configMap?: string;

  /**
   * Secret defines the name of a Secret that holds a CA certificate.
   * The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
   *
   * @schema ServersTransportSpecRootCAs#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'ServersTransportSpecRootCAs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServersTransportSpecRootCAs(obj: ServersTransportSpecRootCAs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': obj.configMap,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spiffe defines the SPIFFE configuration.
 *
 * @schema ServersTransportSpecSpiffe
 */
export interface ServersTransportSpecSpiffe {
  /**
   * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
   *
   * @schema ServersTransportSpecSpiffe#ids
   */
  readonly ids?: string[];

  /**
   * TrustDomain defines the allowed SPIFFE trust domain.
   *
   * @schema ServersTransportSpecSpiffe#trustDomain
   */
  readonly trustDomain?: string;

}

/**
 * Converts an object of type 'ServersTransportSpecSpiffe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServersTransportSpecSpiffe(obj: ServersTransportSpecSpiffe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ids': obj.ids?.map(y => y),
    'trustDomain': obj.trustDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
 *
 * @schema ServersTransportSpecForwardingTimeoutsDialTimeout
 */
export class ServersTransportSpecForwardingTimeoutsDialTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsDialTimeout {
    return new ServersTransportSpecForwardingTimeoutsDialTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsDialTimeout {
    return new ServersTransportSpecForwardingTimeoutsDialTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
 *
 * @schema ServersTransportSpecForwardingTimeoutsIdleConnTimeout
 */
export class ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
    return new ServersTransportSpecForwardingTimeoutsIdleConnTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsIdleConnTimeout {
    return new ServersTransportSpecForwardingTimeoutsIdleConnTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
 *
 * @schema ServersTransportSpecForwardingTimeoutsPingTimeout
 */
export class ServersTransportSpecForwardingTimeoutsPingTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsPingTimeout {
    return new ServersTransportSpecForwardingTimeoutsPingTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsPingTimeout {
    return new ServersTransportSpecForwardingTimeoutsPingTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
 *
 * @schema ServersTransportSpecForwardingTimeoutsReadIdleTimeout
 */
export class ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
    return new ServersTransportSpecForwardingTimeoutsReadIdleTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsReadIdleTimeout {
    return new ServersTransportSpecForwardingTimeoutsReadIdleTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
 *
 * @schema ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout
 */
export class ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
  public static fromNumber(value: number): ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
    return new ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout(value);
  }
  public static fromString(value: string): ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout {
    return new ServersTransportSpecForwardingTimeoutsResponseHeaderTimeout(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

