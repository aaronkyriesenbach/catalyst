// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'npm:cdk8s';
import { Construct } from 'npm:constructs';


/**
 *
 *
 * @schema SecretExport
 */
export class SecretExport extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretExport"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.carvel.dev/v1alpha1',
    kind: 'SecretExport',
  }

  /**
   * Renders a Kubernetes manifest for "SecretExport".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretExportProps): any {
    return {
      ...SecretExport.GVK,
      ...toJson_SecretExportProps(props),
    };
  }

  /**
   * Defines a "SecretExport" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretExportProps) {
    super(scope, id, {
      ...SecretExport.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretExport.GVK,
      ...toJson_SecretExportProps(resolved),
    };
  }
}

/**
 * @schema SecretExport
 */
export interface SecretExportProps {
  /**
   * @schema SecretExport#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema SecretExport#spec
   */
  readonly spec: SecretExportSpec;

}

/**
 * Converts an object of type 'SecretExportProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretExportProps(obj: SecretExportProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretExportSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretExportSpec
 */
export interface SecretExportSpec {
  /**
   * @schema SecretExportSpec#toNamespace
   */
  readonly toNamespace?: string;

  /**
   * @schema SecretExportSpec#toNamespaces
   */
  readonly toNamespaces?: string[];

  /**
   * @schema SecretExportSpec#dangerousToNamespacesSelector
   */
  readonly dangerousToNamespacesSelector?: SecretExportSpecDangerousToNamespacesSelector[];

}

/**
 * Converts an object of type 'SecretExportSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretExportSpec(obj: SecretExportSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'toNamespace': obj.toNamespace,
    'toNamespaces': obj.toNamespaces?.map(y => y),
    'dangerousToNamespacesSelector': obj.dangerousToNamespacesSelector?.map(y => toJson_SecretExportSpecDangerousToNamespacesSelector(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretExportSpecDangerousToNamespacesSelector
 */
export interface SecretExportSpecDangerousToNamespacesSelector {
  /**
   * Property to target the resource for the match. It supports dot notation.
   *
   * @schema SecretExportSpecDangerousToNamespacesSelector#key
   */
  readonly key: string;

  /**
   * Type of comparison.
   *
   * @schema SecretExportSpecDangerousToNamespacesSelector#operator
   */
  readonly operator: SecretExportSpecDangerousToNamespacesSelectorOperator;

  /**
   * Values to match on the resource key using the comparison operator.
   *
   * @schema SecretExportSpecDangerousToNamespacesSelector#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'SecretExportSpecDangerousToNamespacesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretExportSpecDangerousToNamespacesSelector(obj: SecretExportSpecDangerousToNamespacesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of comparison.
 *
 * @schema SecretExportSpecDangerousToNamespacesSelectorOperator
 */
export enum SecretExportSpecDangerousToNamespacesSelectorOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 *
 *
 * @schema SecretImport
 */
export class SecretImport extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretImport"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.carvel.dev/v1alpha1',
    kind: 'SecretImport',
  }

  /**
   * Renders a Kubernetes manifest for "SecretImport".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretImportProps): any {
    return {
      ...SecretImport.GVK,
      ...toJson_SecretImportProps(props),
    };
  }

  /**
   * Defines a "SecretImport" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretImportProps) {
    super(scope, id, {
      ...SecretImport.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretImport.GVK,
      ...toJson_SecretImportProps(resolved),
    };
  }
}

/**
 * @schema SecretImport
 */
export interface SecretImportProps {
  /**
   * @schema SecretImport#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema SecretImport#spec
   */
  readonly spec: SecretImportSpec;

}

/**
 * Converts an object of type 'SecretImportProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretImportProps(obj: SecretImportProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretImportSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretImportSpec
 */
export interface SecretImportSpec {
  /**
   * @schema SecretImportSpec#fromNamespace
   */
  readonly fromNamespace?: string;

}

/**
 * Converts an object of type 'SecretImportSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretImportSpec(obj: SecretImportSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromNamespace': obj.fromNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SecretTemplate allows the construction of secrets using data that reside in other Kubernetes resources
 *
 * @schema SecretTemplate
 */
export class SecretTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretgen.carvel.dev/v1alpha1',
    kind: 'SecretTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "SecretTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretTemplateProps): any {
    return {
      ...SecretTemplate.GVK,
      ...toJson_SecretTemplateProps(props),
    };
  }

  /**
   * Defines a "SecretTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretTemplateProps) {
    super(scope, id, {
      ...SecretTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretTemplate.GVK,
      ...toJson_SecretTemplateProps(resolved),
    };
  }
}

/**
 * SecretTemplate allows the construction of secrets using data that reside in other Kubernetes resources
 *
 * @schema SecretTemplate
 */
export interface SecretTemplateProps {
  /**
   * @schema SecretTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretTemplateSpec contains spec information
   *
   * @schema SecretTemplate#spec
   */
  readonly spec: SecretTemplateSpec;

}

/**
 * Converts an object of type 'SecretTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateProps(obj: SecretTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretTemplateSpec contains spec information
 *
 * @schema SecretTemplateSpec
 */
export interface SecretTemplateSpec {
  /**
   * A list of input resources that are used to construct a new secret. Input Resources can refer to ANY Kubernetes API. If loading more than Secrets types ensure that `.spec.ServiceAccountName` is set to an appropriate value. Input resources are read in the order they are defined. An Input resource's name can be evaluated dynamically from data in a previously evaluated input resource.
   *
   * @schema SecretTemplateSpec#inputResources
   */
  readonly inputResources: SecretTemplateSpecInputResources[];

  /**
   * The Service Account used to read InputResources. If not specified, only Secrets can be read as InputResources.
   *
   * @schema SecretTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * A JSONPath based template that can be used to create Secrets.
   *
   * @schema SecretTemplateSpec#template
   */
  readonly template?: SecretTemplateSpecTemplate;

}

/**
 * Converts an object of type 'SecretTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateSpec(obj: SecretTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputResources': obj.inputResources?.map(y => toJson_SecretTemplateSpecInputResources(y)),
    'serviceAccountName': obj.serviceAccountName,
    'template': toJson_SecretTemplateSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InputResource is references a single Kubernetes resource along with a identifying name
 *
 * @schema SecretTemplateSpecInputResources
 */
export interface SecretTemplateSpecInputResources {
  /**
   * The name of InputResource. This is used as the identifying name in templating to refer to this Input Resource.
   *
   * @schema SecretTemplateSpecInputResources#name
   */
  readonly name: string;

  /**
   * The reference to the Input Resource
   *
   * @schema SecretTemplateSpecInputResources#ref
   */
  readonly ref: SecretTemplateSpecInputResourcesRef;

}

/**
 * Converts an object of type 'SecretTemplateSpecInputResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateSpecInputResources(obj: SecretTemplateSpecInputResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'ref': toJson_SecretTemplateSpecInputResourcesRef(obj.ref),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A JSONPath based template that can be used to create Secrets.
 *
 * @schema SecretTemplateSpecTemplate
 */
export interface SecretTemplateSpecTemplate {
  /**
   * Data key and value. Where key is the Secret Key and the value is a jsonpath surrounded by $( ). The fetched data MUST be base64 encoded. All InputResources are available via their identifying name. For example: key1: $(.secretinput1.data.value1) key2: $(.secretinput2.data.value2)
   *
   * @schema SecretTemplateSpecTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * Metadata contains metadata for the Secret
   *
   * @schema SecretTemplateSpecTemplate#metadata
   */
  readonly metadata?: SecretTemplateSpecTemplateMetadata;

  /**
   * StringData key and value. Where key is the Secret Key and the value can contain a JSONPATH syntax surrounded by $( ). All InputResources are available via their identifying name. For example: key1: static-text key2: $(.input1.spec.value1) key3: combined-$(.input2.status.value2)-$(.input2.status.value3)
   *
   * @schema SecretTemplateSpecTemplate#stringData
   */
  readonly stringData?: { [key: string]: string };

  /**
   * Type is the type of Kubernetes Secret
   *
   * @schema SecretTemplateSpecTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretTemplateSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateSpecTemplate(obj: SecretTemplateSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadata': toJson_SecretTemplateSpecTemplateMetadata(obj.metadata),
    'stringData': ((obj.stringData) === undefined) ? undefined : (Object.entries(obj.stringData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The reference to the Input Resource
 *
 * @schema SecretTemplateSpecInputResourcesRef
 */
export interface SecretTemplateSpecInputResourcesRef {
  /**
   * @schema SecretTemplateSpecInputResourcesRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * @schema SecretTemplateSpecInputResourcesRef#kind
   */
  readonly kind: string;

  /**
   * The name of the input resource. This field can itself contain JSONPATH syntax to load the name dynamically from other input resources. For example this field could be set to a static value of "my-secret" or a dynamic valid of "$(.anotherinputresource.spec.name)".
   *
   * @schema SecretTemplateSpecInputResourcesRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretTemplateSpecInputResourcesRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateSpecInputResourcesRef(obj: SecretTemplateSpecInputResourcesRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata contains metadata for the Secret
 *
 * @schema SecretTemplateSpecTemplateMetadata
 */
export interface SecretTemplateSpecTemplateMetadata {
  /**
   * Annotations to be placed on the generated secret
   *
   * @schema SecretTemplateSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels to be placed on the generated secret
   *
   * @schema SecretTemplateSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SecretTemplateSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretTemplateSpecTemplateMetadata(obj: SecretTemplateSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

