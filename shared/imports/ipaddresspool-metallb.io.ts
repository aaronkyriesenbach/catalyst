// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * IPAddressPool represents a pool of IP addresses that can be allocated
to LoadBalancer services.
 *
 * @schema IPAddressPool
 */
export class IpAddressPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IPAddressPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'metallb.io/v1beta1',
    kind: 'IPAddressPool',
  }

  /**
   * Renders a Kubernetes manifest for "IPAddressPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IpAddressPoolProps): any {
    return {
      ...IpAddressPool.GVK,
      ...toJson_IpAddressPoolProps(props),
    };
  }

  /**
   * Defines a "IPAddressPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IpAddressPoolProps) {
    super(scope, id, {
      ...IpAddressPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IpAddressPool.GVK,
      ...toJson_IpAddressPoolProps(resolved),
    };
  }
}

/**
 * IPAddressPool represents a pool of IP addresses that can be allocated
 * to LoadBalancer services.
 *
 * @schema IPAddressPool
 */
export interface IpAddressPoolProps {
  /**
   * @schema IPAddressPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IPAddressPoolSpec defines the desired state of IPAddressPool.
   *
   * @schema IPAddressPool#spec
   */
  readonly spec: IpAddressPoolSpec;

}

/**
 * Converts an object of type 'IpAddressPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolProps(obj: IpAddressPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IpAddressPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPAddressPoolSpec defines the desired state of IPAddressPool.
 *
 * @schema IpAddressPoolSpec
 */
export interface IpAddressPoolSpec {
  /**
   * A list of IP address ranges over which MetalLB has authority.
   * You can list multiple ranges in a single pool, they will all share the
   * same settings. Each range can be either a CIDR prefix, or an explicit
   * start-end range of IPs.
   *
   * @schema IpAddressPoolSpec#addresses
   */
  readonly addresses: string[];

  /**
   * AutoAssign flag used to prevent MetallB from automatic allocation
   * for a pool.
   *
   * @schema IpAddressPoolSpec#autoAssign
   */
  readonly autoAssign?: boolean;

  /**
   * AvoidBuggyIPs prevents addresses ending with .0 and .255
   * to be used by a pool.
   *
   * @schema IpAddressPoolSpec#avoidBuggyIPs
   */
  readonly avoidBuggyIPs?: boolean;

  /**
   * AllocateTo makes ip pool allocation to specific namespace and/or service.
   * The controller will use the pool with lowest value of priority in case of
   * multiple matches. A pool with no priority set will be used only if the
   * pools with priority can't be used. If multiple matching IPAddressPools are
   * available it will check for the availability of IPs sorting the matching
   * IPAddressPools by priority, starting from the highest to the lowest. If
   * multiple IPAddressPools have the same priority, choice will be random.
   *
   * @schema IpAddressPoolSpec#serviceAllocation
   */
  readonly serviceAllocation?: IpAddressPoolSpecServiceAllocation;

}

/**
 * Converts an object of type 'IpAddressPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpec(obj: IpAddressPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'autoAssign': obj.autoAssign,
    'avoidBuggyIPs': obj.avoidBuggyIPs,
    'serviceAllocation': toJson_IpAddressPoolSpecServiceAllocation(obj.serviceAllocation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllocateTo makes ip pool allocation to specific namespace and/or service.
 * The controller will use the pool with lowest value of priority in case of
 * multiple matches. A pool with no priority set will be used only if the
 * pools with priority can't be used. If multiple matching IPAddressPools are
 * available it will check for the availability of IPs sorting the matching
 * IPAddressPools by priority, starting from the highest to the lowest. If
 * multiple IPAddressPools have the same priority, choice will be random.
 *
 * @schema IpAddressPoolSpecServiceAllocation
 */
export interface IpAddressPoolSpecServiceAllocation {
  /**
   * NamespaceSelectors list of label selectors to select namespace(s) for ip pool,
   * an alternative to using namespace list.
   *
   * @schema IpAddressPoolSpecServiceAllocation#namespaceSelectors
   */
  readonly namespaceSelectors?: IpAddressPoolSpecServiceAllocationNamespaceSelectors[];

  /**
   * Namespaces list of namespace(s) on which ip pool can be attached.
   *
   * @schema IpAddressPoolSpecServiceAllocation#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Priority priority given for ip pool while ip allocation on a service.
   *
   * @schema IpAddressPoolSpecServiceAllocation#priority
   */
  readonly priority?: number;

  /**
   * ServiceSelectors list of label selector to select service(s) for which ip pool
   * can be used for ip allocation.
   *
   * @schema IpAddressPoolSpecServiceAllocation#serviceSelectors
   */
  readonly serviceSelectors?: IpAddressPoolSpecServiceAllocationServiceSelectors[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocation(obj: IpAddressPoolSpecServiceAllocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectors(y)),
    'namespaces': obj.namespaces?.map(y => y),
    'priority': obj.priority,
    'serviceSelectors': obj.serviceSelectors?.map(y => toJson_IpAddressPoolSpecServiceAllocationServiceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors
 */
export interface IpAddressPoolSpecServiceAllocationNamespaceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors#matchExpressions
   */
  readonly matchExpressions?: IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectors(obj: IpAddressPoolSpecServiceAllocationNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema IpAddressPoolSpecServiceAllocationServiceSelectors
 */
export interface IpAddressPoolSpecServiceAllocationServiceSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectors#matchExpressions
   */
  readonly matchExpressions?: IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationServiceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationServiceSelectors(obj: IpAddressPoolSpecServiceAllocationServiceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions
 */
export interface IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions(obj: IpAddressPoolSpecServiceAllocationNamespaceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions
 */
export interface IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions(obj: IpAddressPoolSpecServiceAllocationServiceSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

